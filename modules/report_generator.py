import os
import shutil

def generate_markdown_report(title, filename, score, image_path, synthesis, output_path):
    """
    DEPRECATED: Generates a Markdown report for a single paper.
    Kept for backward compatibility if needed, but main workflow now uses consolidated report.
    """
    pass

def generate_consolidated_report(results_list, output_path, keywords):
    """
    Generates a single consolidated Markdown report for all processed papers.
    
    Args:
        results_list (list): List of dicts containing:
            {
                "title": str,
                "filename": str,
                "score": int,
                "image_path": str,
                "synthesis": str
            }
        output_path (str): Path to save the consolidated .md file.
        keywords (str): Keywords used for search/scoring.
    """
    # Ensure directory exists
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    # Sort results by score (Descending)
    results_list.sort(key=lambda x: x["score"], reverse=True)
    
    # Header
    markdown_content = f"# Paper Analysis Report\n\n"
    markdown_content += f"**Keywords:** {keywords}\n"
    from datetime import datetime
    markdown_content += f"**Date:** {datetime.now().strftime('%Y-%m-%d')}\n\n"
    
    # Table of Contents
    markdown_content += "## Table of Contents (Sorted by Relevance)\n\n"
    for i, res in enumerate(results_list):
        # Create anchor link
        anchor = res["title"].lower().replace(" ", "-").replace(":", "").replace(".", "")
        # Remove non-alphanumeric except dashes
        import re
        anchor = re.sub(r'[^a-z0-9-]', '', anchor)
        
        markdown_content += f"{i+1}. [{res['title']} (Score: {res['score']}/10)](#{anchor})\n"
    
    markdown_content += "\n---\n\n"
    
    # Paper Details
    for res in results_list:
        title = res["title"]
        synthesis = res["synthesis"]
        image_path = res["image_path"]
        
        # Calculate relative image path
        relative_image_path = os.path.relpath(image_path, os.path.dirname(output_path))
        # Fix Windows path separators for Markdown
        relative_image_path = relative_image_path.replace("\\", "/")
        
        # Inject image into synthesis (same logic as before)
        if "## 3. Core Architecture and Method" in synthesis:
            image_markdown = f"\n![Model Architecture]({relative_image_path})\n*(Note: Figure automatically extracted by system)*\n"
            synthesis = synthesis.replace("## 3. Core Architecture and Method", f"## 3. Core Architecture and Method{image_markdown}")
        else:
            synthesis = f"![Model Architecture]({relative_image_path})\n\n{synthesis}"
            
        markdown_content += f"# {title}\n\n"
        markdown_content += f"**Source File:** `{res['filename']}`\n\n"
        markdown_content += f"{synthesis}\n\n"
        markdown_content += "---\n\n"
        
    markdown_content += "*Generated by GLM Dual-Brain Agent*"
    
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(markdown_content)
    
    print(f"Consolidated report generated: {output_path}")

def cleanup_temp_files(image_path):
    """
    Removes the temporary image file. 
    Use this if we truly want to be 'stateless' and maybe embed image or just discard it.
    But based on "relative path" requirement, we probably shouldn't delete the final image 
    unless the report is self-contained (base64).
    
    Let's assume we DON'T delete the final image for now, but we would delete any other temp files.
    Since we only generate one image per paper (the crop), maybe we keep it.
    
    If the user insists on "Stateless Cleanup", maybe they mean cleanup *after* the session or just intermediate files.
    I will leave this function available but maybe not call it on the *result* image.
    """
    if os.path.exists(image_path):
        os.remove(image_path)
        print(f"Deleted temp file: {image_path}")
